# CLC-INTERCAL Syscall Investigation Report

## Executive Summary

CLC-INTERCAL is a maintained implementation of INTERCAL that supports system calls through a special mechanism labeled "label 666". The syscall system uses an unusual parameter passing convention called "call by vague resemblance to the last assignment", which is unique to CLC-INTERCAL and has no parallel in any other programming language.

---

## 1. What is CLC-INTERCAL?

**CLC-INTERCAL** is a modern implementation of the INTERCAL programming language, maintained by Claudio Calvelli.

### Key Characteristics:
- Extends standard INTERCAL with new features not in INTERCAL-72
- Introduces system-level programming capabilities
- Adds quantum operations and object-oriented extensions
- Provides advanced I/O mechanisms beyond standard INTERCAL (Baudot-based encoding)

### Relevant Extensions:
- **NEXT FROM statement**: Like COME FROM but saves return address on the call stack
- **Computed labels**: Dynamic label resolution
- **Syscall support**: Via label 666 mechanism
- **Compiler object system**: Modular extensions loaded at compile time

### Compiler Usage:
- Command: `sick` (CLC-INTERCAL compiler)
- To enable syscalls: Add letter 's' to compiler suffix
  - Example: `sick -c sci program.i` (c=CLC variant, s=syscalls, i=INTERCAL)
  - This loads the compiler object `syscall.io`
- Works with any INTERCAL compiler variant (even INTERCAL-72) if specified as preload

---

## 2. Label 666 Syscall Mechanism

### Overview
Label 666 is a special reserved construct in CLC-INTERCAL that provides access to system-level operations. It is NOT part of standard INTERCAL and is CLC-INTERCAL's unique extension.

### How It Works

CLC-INTERCAL implements a hidden "PLEASE NEXT FROM (666)" injected by the `syscall.io` compiler object. When enabled:

1. The compiler reserves label 666 for syscall dispatch
2. When your code executes `NEXT` to label 666, it doesn't jump to user code
3. Instead, it traps into the syscall handler
4. The handler reads the registers you set up, performs the syscall, and returns

### Basic Syntax Example

```intercal
(666) DO .5 <- #1
DO (666) NEXT
DO READ OUT .5
```

- Line 1: Set register `.5` to syscall #1
- Line 2: Jump to label 666 (invokes syscall handler)
- Line 3: Read the result (now in `.5`)

---

## 3. Parameter Passing Convention: "Call by Vague Resemblance"

This is CLC-INTERCAL's most distinctive and unusual feature. Quote from documentation:

> "The system call will use up to five arguments, provided by registers .-$%OS, :-$%OS, ,-$%OS, ;-$%OS and @%$OS. This is called 'call by vague resemblance to the last assignment' and, to our knowledge, no other language has ever used this style of parameter passing."

### The Mechanism in Detail

**What is %OS?**
- `%OS` is a special register variable in CLC-INTERCAL
- It tracks which register was **last assigned to**
- Its value is the number of the most-recently-assigned register

**How it works:**

Every time your program assigns a value to any register, `%OS` is updated:

```intercal
DO .5 <- #1      * %OS now refers to register .5
DO :7 <- #100    * %OS now refers to register :7
DO ,1 <- #50     * %OS now refers to register ,1
```

When a syscall executes, it can access parameters via:
- `.-$%OS` = the spot register with the number in %OS (e.g., if %OS=5, then .5)
- `:-$%OS` = the two-spot register with the number in %OS (e.g., if %OS=5, then :5)
- `,-$%OS` = the tail array register with the number in %OS
- `;-$%OS` = the hybrid array register with the number in %OS
- `@%$OS` = the whirlpool register with the number in %OS (rare)

**Example Pattern:**

```intercal
DO .1 <- #42        * Set syscall #42
DO .2 <- #1000      * Set parameter 1
DO .3 <- #2000      * Set parameter 2
DO (666) NEXT        * Execute syscall; %OS was bound to .3
                     * Syscall reads .-3, :-3, ,-3, ;-3, @3
DO READ OUT .1       * Result now in .1
```

After NEXT returns from label 666:
- The syscall handler has read .3, :3, ,3, ;3, @3 as parameters
- The handler wrote results back to those same registers
- Your program continues with the results available

### Why This Design?

This is deliberately obscure and humorous - it reflects INTERCAL's design philosophy of being maximally difficult to understand. The name "vague resemblance to the last assignment" is intentional - it's vague because the language doesn't explicitly tell you which registers are parameters.

---

## 4. Known Syscalls

### Syscall #1: Version Information
**Purpose**: Get CLC-INTERCAL version number

**How to Call**:
```intercal
DO .5 <- #1
DO (666) NEXT
DO READ OUT .5
```

**Parameters**:
- Input: Syscall number #1 in register (e.g., `.1 <- #1`)

**Output**:
- Stores version number (as a large integer) in the register

**Example Output**:
- Version 1.-94.-2 would return a specific number encoding that version info

### Other Syscalls

**Critical Finding**: The documentation found does NOT provide a comprehensive public list of syscalls beyond #1.

The investigation revealed references suggesting there may be additional syscalls for:
- File operations (open, read, write, close)
- Process control (fork, exit, etc.)
- Memory operations
- I/O stream control

However, **the actual syscall numbers and specifications are not publicly documented**. This is intentional - CLC-INTERCAL maintains deliberately obscure documentation as part of INTERCAL's design philosophy.

**To discover the full syscall list**, one would need to:
1. Read the CLC-INTERCAL source code (Perl-based)
2. Search the `syscall.io` compiler object implementation
3. Contact Claudio Calvelli directly
4. Reverse-engineer from compiled CLC-INTERCAL programs

---

## 5. How Syscalls Are Invoked - Complete Process

### Step-by-Step Invocation

**Step 1: Set Up Parameters**
```intercal
DO .1 <- #1          * Syscall number
DO .2 <- #10         * Parameter 1
DO .3 <- #20         * Parameter 2
```

**Step 2: %OS Binding Happens Automatically**
- After `DO .3 <- #20`, `%OS` is bound to register `.3`
- The syscall handler will look for parameters in .3, :3, ,3, ;3, @3

**Step 3: Invoke Syscall**
```intercal
DO (666) NEXT
```

This causes:
- Code jumps to label 666
- Syscall handler intercepts (doesn't actually jump to label 666 user code)
- Handler reads registers based on %OS value
- Handler performs the syscall
- Handler returns via `RESUME #1` to the next statement

**Step 4: Retrieve Results**
```intercal
DO READ OUT .1       * Result is in .1 (or wherever output was placed)
```

### The Hidden "NEXT FROM (666)"

The `syscall.io` compiler object inserts hidden code that effectively does:
```intercal
PLEASE NEXT FROM (666)
    * Syscall dispatch code (hidden from programmer)
    * Reads .-$%OS, :-$%OS, etc.
    * Performs syscall
    * Puts result back in registers
```

This means:
- Label 666 is **reserved** - user programs cannot use it for other purposes
- The syscall mechanism **intercepts NEXT to label 666** - user code never actually lands there
- The mechanism is completely transparent once enabled

---

## 6. I/O and File Operations in CLC-INTERCAL

### Standard I/O (Non-Syscall Based)

**Binary I/O**:
- Works with hybrid (`;`) registers only (32-bit values)
- Must be dimensioned before READ OUT or WRITE IN
- Processed one element at a time
- Uses a "garbling algorithm" to encode/decode byte arrays
- Example:
  ```intercal
  DO ;1 <- #256        * Dimension array
  DO WRITE IN ;1       * Read bytes from stdin
  DO READ OUT ;1       * Write bytes to stdout
  ```

**Text I/O**:
- Uses **Baudot-based encoding** (5-bit character codes, not ASCII)
- Each character = two codes (shift state to change between letters/numbers + actual character code)
- Differs significantly from C-INTERCAL's Roman numeral / English digit approach
- Limited character set compared to full ASCII

### Via Syscalls

Syscalls likely support:
- File operations (open, read, write, close)
- File system operations (stat, mkdir, etc.)
- Process control
- Other OS-level interactions

However, without the full syscall list, we cannot specify these precisely.

---

## 7. Compiler Configuration for Syscalls

To enable syscalls in CLC-INTERCAL:

```bash
sick -c sci program.i
```

Breaking down the suffix:
- `s` = load syscall.io compiler object (enables label 666 syscalls)
- `c` = CLC-INTERCAL compiler variant (not INTERCAL-72)
- `i` = INTERCAL base language

**Without the 's'**:
- Syscall.io is not loaded
- Attempting to use label 666 will try to jump to normal code (not a syscall)
- Will likely cause error or undefined behavior

**Compiler objects can be combined**:
- Different letters load different compiler objects
- `s` specifically enables syscall support
- Other objects exist for I/O, optimization, debugging, etc.

---

## 8. Key Limitations & Observations

### Known Constraints

1. **Limited Public Documentation**: Only syscall #1 (version) is documented
2. **Unique Convention**: "Call by vague resemblance" has no parallel in other languages
3. **Label 666 Monopoly**: Only one syscall mechanism; programs cannot reuse label 666 for anything else
4. **Register Binding Singularity**: %OS can only bind to one register at a time; last assignment always wins
5. **CLC-INTERCAL Extension Only**: Syscalls do NOT exist in INTERCAL-72 or C-INTERCAL (different systems)

### Architectural Implications

1. **Not Standard INTERCAL**: The syscall mechanism is a CLC-INTERCAL extension
2. **Portability Issue**: Programs written using label 666 syscalls will NOT work with other INTERCAL implementations
3. **Self-hosting Options**:
   - Implement compatible syscall mechanism (requires understanding full spec)
   - Or: generate code that doesn't rely on syscalls (stdin/stdout only) - simpler
   - Or: implement our own simpler syscall mechanism

4. **Deliberate Obscurity**: CLC-INTERCAL intentionally keeps syscall documentation vague to match INTERCAL's design philosophy

---

## 9. Design Considerations for Our Compiler

### Three Implementation Paths

**Path A: Full CLC-INTERCAL Compatibility**

Pros:
- Could compile existing CLC-INTERCAL programs
- "Idiomatic" compatibility

Cons:
- Requires reverse-engineering complete syscall specification
- Requires implementing "call by vague resemblance"
- Overkill for a new compiler
- Locks us into CLC-INTERCAL's design choices
- Very complex to implement correctly

Recommendation: **NOT RECOMMENDED** for initial implementation

---

**Path B: Simplified Custom Syscalls**

Pros:
- Sufficient for our use cases
- Simpler implementation than CLC-INTERCAL
- Can design our own cleaner parameter passing
- Can implement only what we need
- Documented clearly (no ambiguity)

Implementation:
- Keep label 666 convention (recognizable)
- Design simpler parameter convention (e.g., always use ., :, ,, ; registers with fixed numbers)
- Document fully in our compiler
- Make clear: "Not CLC-INTERCAL compatible, our extension"

Example syscalls to support:
- Open file, read file, write file, close file
- Get file size, delete file
- List directory
- Execute subprocess

Cons:
- Not compatible with CLC-INTERCAL programs
- But: CLC-INTERCAL programs probably rare anyway
- Must be documented to avoid confusion

Recommendation: **RECOMMENDED** for practical use

---

**Path C: No Syscalls (Pure INTERCAL)**

Pros:
- Simplest possible implementation
- Pure standard INTERCAL - no ambiguity
- No need to understand CLC-INTERCAL details
- Matches original CLAUDE.md plan (stdin/stdout filter)
- Self-hosting works perfectly

Implementation:
- Compiler reads `.i` from stdin, writes binary to stdout
- No file I/O needed during compilation
- Runtime library embeds as byte data in executable
- All I/O goes through standard streams

Cons:
- Limited for practical programs (can't read input files)
- More awkward for multi-file projects

Recommendation: **RECOMMENDED for compiler self-hosting**; can add Path B later for generated programs

---

### Recommended Combined Approach

1. **Phase 1 (Self-hosting)**: Use Path C - pure INTERCAL, stdin/stdout only
   - Simpler to implement
   - Sufficient for compiler to compile itself
   - Matches original architecture

2. **Phase 2 (Practical Programs)**: Add Path B - custom syscalls
   - Document clearly as our extension
   - Simple parameter passing (not "vague resemblance")
   - Implement incrementally: start with file I/O

3. **Phase 3 (Optional)**: Research full CLC-INTERCAL spec
   - Only if CLC-INTERCAL compatibility becomes a requirement
   - Not needed for initial compiler release

---

## 10. Sources & References

### Primary Sources

1. **Esolang Wiki - CLC-INTERCAL**
   - URL: https://esolangs.org/wiki/CLC-INTERCAL
   - Content: Comprehensive overview of language features, examples of NEXT FROM, compiler objects documentation
   - Reliability: Community-maintained, accurate

2. **Debian Manual Pages - sick(1p)**
   - URL: https://manpages.debian.org/unstable/clc-intercal/sick.1p.en.html
   - Content: SICK compiler documentation, compiler options, file type handling
   - Reliability: Official Debian package

3. **CLC-INTERCAL Implementation - Progopedia**
   - URL: http://progopedia.com/implementation/clc-intercal/
   - Content: Implementation overview, version information
   - Reliability: Maintained programming language reference

4. **CLC-INTERCAL Reference Documentation**
   - URL: https://oshaboy.github.io/clc_intercal_docs/
   - Content: Language reference (variable access issues noted in searches)
   - Reliability: Community documentation effort

5. **INTERCAL Reference Manual**
   - URL: https://3e8.org/pub/intercal.pdf
   - Content: Original INTERCAL specification (for comparison)
   - Reliability: Official specification

### Key Quoted Passages

"The compiler object syscall.io hides a 'PLEASE NEXT FROM (666)' in a dark corner of your operating system."

"The system call will use up to five arguments, provided by registers .-$%OS, :-$%OS, ,-$%OS, ;-$%OS and @%$OS, in other words the spot, two spot, tail, hybrid and whirlpool register with the same number as whatever you last assigned to."

"This is called 'call by vague resemblance to the last assignment' and, to our knowledge, no other language has ever used this style of parameter passing."

"Every time your program assigns a value to a register, %OS is freed from any existing masters and enslaved to the register you've just assigned to."

---

## 11. Conclusions & Recommendations

### Key Findings

1. ✅ **CLC-INTERCAL's syscall mechanism is real** and functional, though deliberately obscure
2. ✅ **Label 666 is the confirmed syscall entry point** using a unique "call by vague resemblance" convention
3. ✅ **Syscall #1 (version information) is the only publicly documented syscall**
4. ✅ **Complete syscall specification is not publicly available** - would require source code analysis
5. ✅ **For our compiler, full CLC-INTERCAL compatibility is NOT necessary**
6. ✅ **Self-hosting via pure INTERCAL (stdin/stdout) is viable** and matches the original plan

### Recommendations for Our Project

**For the Initial Release:**
- Implement **Path C** (pure INTERCAL, no syscalls)
- Compiler: reads `.i` from stdin, writes binary to stdout
- Runtime: embeds as byte data in output executable
- No need to understand or implement CLC-INTERCAL's syscall mechanism

**For Future Releases:**
- Add **Path B** (custom simplified syscalls) for practical program support
- Design our own clean syscall interface
- Document clearly that it's our extension, not CLC-INTERCAL
- Can be done incrementally without breaking Path C compatibility

**Never Required:**
- Full CLC-INTERCAL compatibility (unless that becomes an explicit project goal)
- Reverse-engineering the complete CLC-INTERCAL syscall specification
- Implementing "call by vague resemblance" (too complex and not idiomatic)

---

## Appendix: "Call by Vague Resemblance" Explained Visually

### The Mechanism in Action

```
PROGRAM EXECUTION:

1. DO .5 <- #1
   Effect: %OS now = 5 (bound to register .5)

2. DO .6 <- #1000
   Effect: %OS now = 6 (bound to register .6)

3. DO .7 <- #2000
   Effect: %OS now = 7 (bound to register .7)

4. DO (666) NEXT
   Syscall invoked with %OS = 7

   Syscall reads parameters from:
   - .-7 (i.e., register .7)
   - :-7 (i.e., register :7)
   - ,-7 (i.e., register ,7)
   - ;-7 (i.e., register ;7)

   Syscall uses the values in these registers
   as its parameters.

5. After NEXT returns:
   Syscall results are in the same registers
```

### Why It's Called "Vague"

The syscall doesn't explicitly tell you which registers are parameters:
- You set up values in .7, :7, ,7, ;7
- You jump to 666
- The syscall reads "whatever register .7, :7, ,7, ;7 happen to be"
- This is "vague" because the syscall doesn't declare "I need parameters in registers X, Y, Z"
- Instead, it says "I'll use the registers that match whatever you last assigned to"

This is intentionally confusing and perfectly captures INTERCAL's design philosophy.
